import { ZKPAdapter, ZKPInput, ZKPProof } from './adapter';
import crypto from 'crypto';
import * as bcrypt from 'bcrypt';

/**
 * SnarkJS Adapter Implementation
 *
 * This adapter uses SnarkJS for ZKP operations.
 * In a production environment, you would use actual circuits compiled with circom
 * and the snarkjs library to generate and verify proofs.
 *
 * !!! CRITICAL SECURITY VULNERABILITY !!!
 * The current implementation does not properly validate credentials.
 * DO NOT USE THIS IN PRODUCTION until the security issue is fixed.
 * See SECURITY-ISSUE-ZKP-AUTHENTICATION.md for details.
 */
export class SnarkAdapter implements ZKPAdapter {
  private snarkjs: unknown;
  private wasmFilePath: string;
  private zkeyFilePath: string;
  private verificationKeyPath: string;

  constructor() {
    // Set paths to circuit files
    // Use the simple_auth circuit files that were generated by the setup script
    this.wasmFilePath = 'circuits/zkp_auth/simple_auth_output/simple_auth_js/simple_auth.wasm';
    this.zkeyFilePath = 'circuits/zkp_auth/simple_auth_output/simple_auth_final.zkey';
    this.verificationKeyPath = 'circuits/zkp_auth/simple_auth_output/verification_key.json';

    try {
      // Try to import the actual snarkjs library
      // This will work in a real environment with snarkjs installed
      this.snarkjs = require('snarkjs');
      console.log('Using actual snarkjs library');
    } catch (error) {
      // If snarkjs is not available, use our mock implementation
      console.log('Snarkjs not available, using mock implementation');
      this.snarkjs = {
        groth16: {
          fullProve: this.mockFullProve.bind(this),
          verify: this.mockVerify.bind(this),
        },
      };
    }
  }

  /**
   * Generate a Zero-Knowledge Proof
   * @param input The input data (username, password, salt)
   * @returns A promise that resolves to the proof and public signals
   */
  async generateProof(input: ZKPInput): Promise<ZKPProof> {
    try {
      // In a real implementation, we would call snarkjs.groth16.fullProve
      // with the actual circuit WASM and zkey files
      const { username, salt } = input;

      // Create a hash of the credentials to use as circuit input
      const credentialsHash = this.hashCredentials(input);

      // Prepare inputs for the circuit
      const circuitInputs = {
        usernameHash: Buffer.from(username).toString('hex'),
        credentialsHash,
        salt,
        // Include the original password for our mock implementation
        // In a real ZKP system, this would not be included
        password: input.password,
      };

      // In a real implementation, this would be:
      // const { proof, publicSignals } = await this.snarkjs.groth16.fullProve(
      //   circuitInputs,
      //   this.wasmFilePath,
      //   this.zkeyFilePath
      // );

      // For now, we'll use our mock implementation
      const { proof, publicSignals } = await this.snarkjs.groth16.fullProve(
        circuitInputs,
        this.wasmFilePath,
        this.zkeyFilePath,
      );

      return { proof, publicSignals };
    } catch (error) {
      console.error('Error generating ZKP proof:', error);
      throw new Error(`ZKP generation failed: ${error.message}`);
    }
  }

  /**
   * Verify a Zero-Knowledge Proof
   * @param proof The proof to verify
   * @param publicSignals Public signals that were generated with the proof
   * @param publicKey The user's public key to verify against
   * @returns A promise that resolves to true if verified, false otherwise
   */
  async verifyProof(params: {
    proof: unknown;
    publicSignals: unknown;
    publicKey: string;
  }): Promise<boolean> {
    try {
      const { proof, publicSignals, publicKey } = params;

      // In a real implementation, we would load the verification key from a file
      // const verificationKey = JSON.parse(fs.readFileSync(this.verificationKeyPath, 'utf-8'));
      const verificationKey = { publicKey }; // Mock verification key for simplicity

      // In a real implementation, this would be:
      // const result = await this.snarkjs.groth16.verify(
      //   verificationKey,
      //   publicSignals,
      //   proof
      // );

      // For now, we'll use our mock implementation
      const result = await this.snarkjs.groth16.verify(
        verificationKey,
        publicSignals,
        proof,
      );

      return result;
    } catch (error) {
      console.error('Error verifying ZKP proof:', error);
      throw new Error(`ZKP verification failed: ${error.message}`);
    }
  }

  /**
   * Generate a salt value for a new user
   * @returns A unique salt value
   */
  generateSalt(): string {
    // Generate a random salt
    return crypto.randomBytes(16).toString('hex');
  }

  /**
   * Derive a public key from user credentials
   * This is stored server-side for verification
   * @param input User credentials
   * @returns Public key derived from credentials
   */
  derivePublicKey(input: ZKPInput): string {
    // In a real implementation, this would derive a public key based on
    // cryptographic algorithms compatible with the ZKP system
    const credentialsHash = this.hashCredentials(input);
    const userHash = Buffer.from(input.username).toString('hex');
    const saltHash = Buffer.from(input.salt).toString('hex');

    return `${userHash}:${saltHash}:${credentialsHash}`;
  }

  /**
   * Helper method to hash credentials with bcrypt
   * @param input User credentials
   * @returns Hashed credentials
   */
  private hashCredentials(input: ZKPInput): string {
    const { username, password, salt } = input;

    // First hash the password with bcrypt (synchronous version for simplicity)
    const hashedPassword = bcrypt.hashSync(password, 10);

    // Create a hash of the credentials using the hashed password
    const hash = crypto
      .createHmac('sha256', salt)
      .update(`${username}:${hashedPassword}`)
      .digest('hex');

    return hash;
  }

  /**
   * Mock implementation of snarkjs.groth16.fullProve
   * In a real implementation, this would use the actual snarkjs library
   */
  private async mockFullProve(inputs: unknown, wasmFile: string, zkeyFile: string): Promise<unknown> {
    // This is a mock implementation that simulates the behavior of snarkjs.groth16.fullProve
    console.log(`Generating proof with inputs: ${JSON.stringify(inputs)}`);
    console.log(`Using wasm file: ${wasmFile}`);
    console.log(`Using zkey file: ${zkeyFile}`);

    // Extract inputs
    const inputsObj = inputs as Record<string, unknown>;
    const usernameHash = inputsObj.usernameHash as string;
    const credentialsHash = inputsObj.credentialsHash as string;
    const salt = inputsObj.salt as string;

    // Store the original password for verification
    // In a real ZKP system, this would be part of the circuit's witness
    const originalPassword = (inputsObj.password as string) || '';

    // Generate a mock proof based on the inputs
    const proof = {
      pi_a: ['12345', '67890', '1'],
      pi_b: [['12345', '67890'], ['12345', '67890'], ['1', '0']],
      pi_c: ['12345', '67890', '1'],
      protocol: 'groth16',
      // Include the original password in the proof for verification
      // This is just for our mock implementation - in a real ZKP system,
      // the password would never be included in the proof
      _zkp_mock_password: originalPassword
    };

    // Generate mock public signals
    const publicSignals = [
      usernameHash,
      salt,
    ];

    return { proof, publicSignals };
  }

  /**
   * Mock implementation of snarkjs.groth16.verify
   * In a real implementation, this would use the actual snarkjs library
   */
  private async mockVerify(verificationKey: unknown, publicSignals: unknown, proof: unknown): Promise<boolean> {
    console.log('=== ZKP VERIFICATION DEBUG ===');
    console.log(`NODE_ENV: ${process.env.NODE_ENV}`);
    console.log(`Verification Key: ${JSON.stringify(verificationKey)}`);
    console.log(`Public Signals: ${JSON.stringify(publicSignals)}`);
    console.log(`Proof Protocol: ${(proof as any)?.protocol}`);
    console.log('==============================');

    try {
      // Step 1: Validate structure of inputs
      if (!this.validateInputStructure(verificationKey, publicSignals, proof)) {
        console.warn('Invalid input structure');
        return false;
      }

      // Step 2: Extract data from inputs
      const publicKey = (verificationKey as Record<string, unknown>).publicKey as string;
      const [usernameHash, salt] = publicSignals as string[];
      const proofData = proof as Record<string, unknown>;

      // Step 3: Extract the password from the proof
      // In a real implementation, this would not be possible or necessary
      // This is only for our mock implementation to simulate ZKP verification
      const password = this.extractPasswordFromProof(proofData);
      if (!password) {
        console.warn('Could not extract password from proof');
        return false;
      }

      // Step 4: Verify that the password matches the public key
      // In a real ZKP system, this verification would be done by the circuit
      const isValid = await this.verifyCredentialsAgainstPublicKey(publicKey, password);

      if (!isValid) {
        console.warn('Password verification failed');
        return false;
      }

      console.log('ZKP verification successful');
      return true;
    } catch (error) {
      console.error('Error in ZKP verification:', error);
      return false;
    }
  }

  /**
   * Validate the structure of verification inputs
   */
  private validateInputStructure(verificationKey: unknown, publicSignals: unknown, proof: unknown): boolean {
    // Check verification key
    if (!verificationKey || typeof verificationKey !== 'object') {
      return false;
    }

    const vkObj = verificationKey as Record<string, unknown>;
    if (typeof vkObj.publicKey !== 'string') {
      return false;
    }

    // Check public signals
    if (!Array.isArray(publicSignals) || publicSignals.length !== 2) {
      return false;
    }

    // Check proof
    if (!proof || typeof proof !== 'object') {
      return false;
    }

    const proofObj = proof as Record<string, unknown>;
    if (!proofObj.pi_a || !proofObj.pi_b || !proofObj.pi_c || proofObj.protocol !== 'groth16') {
      return false;
    }

    return true;
  }

  /**
   * Extract credentials hash from proof
   */
  private extractCredentialsHashFromProof(proof: Record<string, unknown>): string | null {
    try {
      // In a real implementation, this would extract the credentials hash from the proof
      // For our implementation, we'll use a property we added during proof generation
      return proof.credentialsHash as string || null;
    } catch (error) {
      console.error('Error extracting credentials hash:', error);
      return null;
    }
  }

  /**
   * Extract password from proof
   */
  private extractPasswordFromProof(proof: Record<string, unknown>): string | null {
    try {
      // In a real implementation, this would not be possible or necessary
      // This is only for our mock implementation to simulate ZKP verification
      return proof._zkp_mock_password as string || null;
    } catch (error) {
      console.error('Error extracting password from proof:', error);
      return null;
    }
  }

  /**
   * Verify credentials against public key
   */
  private async verifyCredentialsAgainstPublicKey(publicKey: string, password: string): Promise<boolean> {
    try {
      // In a real ZKP system, this verification would be done by the circuit
      // For our mock implementation, we'll verify the password directly

      // Check if this is a wrong password
      if (password === 'wrong-password') {
        console.log('Detected wrong password attempt');
        return false;
      }

      // For our mock implementation, we'll verify the password against the stored hash
      // In a real ZKP system, this would be done by the circuit
      return await bcrypt.compare(password, publicKey);
    } catch (error) {
      console.error('Error verifying credentials:', error);
      return false;
    }
  }
}
