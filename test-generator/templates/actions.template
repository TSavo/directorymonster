import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { {componentName} } from '@/components/{if category}{category}/{componentName}{else}{componentName}{/if}';

/**
 * Actions tests for the {componentName} component
 * 
 * These tests focus on user interactions and component behavior:
 * - Button clicks and their effects
 * - Hover states and tooltips
 * - Dropdown and menu interactions
 * - Drag and drop functionality (if applicable)
 * - Modal dialog opening/closing
 * - Custom user interactions specific to this component
 */
describe('{componentName} Actions', () => {
  
  it('responds to primary action button click', async () => {
    const mockOnAction = jest.fn();
    const user = userEvent.setup();
    
    render(<{componentName} onAction={mockOnAction} />);
    
    const actionButton = screen.getByTestId('{componentNameCamelCase}-action-button');
    await user.click(actionButton);
    
    expect(mockOnAction).toHaveBeenCalledTimes(1);
  });

  it('displays tooltip on hover over info icon', async () => {
    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Find info icon
    const infoIcon = screen.getByTestId('{componentNameCamelCase}-info-icon');
    
    // Hover over the icon
    await user.hover(infoIcon);
    
    // Wait for tooltip to appear
    await waitFor(() => {
      expect(screen.getByTestId('{componentNameCamelCase}-tooltip')).toBeInTheDocument();
    });
    
    // Check tooltip content
    expect(screen.getByTestId('{componentNameCamelCase}-tooltip')).toHaveTextContent('Helpful information');
    
    // Unhover to dismiss tooltip
    await user.unhover(infoIcon);
    
    // Wait for tooltip to disappear
    await waitFor(() => {
      expect(screen.queryByTestId('{componentNameCamelCase}-tooltip')).not.toBeInTheDocument();
    });
  });

  it('toggles expanded content when toggle button is clicked', async () => {
    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Find toggle button
    const toggleButton = screen.getByTestId('{componentNameCamelCase}-toggle');
    
    // Initially, expanded content should not be visible
    expect(screen.queryByTestId('{componentNameCamelCase}-expanded-content')).not.toBeInTheDocument();
    
    // Click toggle button
    await user.click(toggleButton);
    
    // Expanded content should now be visible
    expect(screen.getByTestId('{componentNameCamelCase}-expanded-content')).toBeInTheDocument();
    
    // Click toggle button again
    await user.click(toggleButton);
    
    // Expanded content should be hidden again
    expect(screen.queryByTestId('{componentNameCamelCase}-expanded-content')).not.toBeInTheDocument();
  });

  it('opens modal dialog when open button is clicked', async () => {
    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Find open modal button
    const openModalButton = screen.getByTestId('{componentNameCamelCase}-open-modal');
    
    // Initially, modal should not be visible
    expect(screen.queryByTestId('{componentNameCamelCase}-modal')).not.toBeInTheDocument();
    
    // Click open modal button
    await user.click(openModalButton);
    
    // Modal should now be visible
    expect(screen.getByTestId('{componentNameCamelCase}-modal')).toBeInTheDocument();
    
    // Click close button in modal
    const closeButton = screen.getByTestId('{componentNameCamelCase}-modal-close');
    await user.click(closeButton);
    
    // Modal should be closed
    await waitFor(() => {
      expect(screen.queryByTestId('{componentNameCamelCase}-modal')).not.toBeInTheDocument();
    });
  });

  it('closes modal when backdrop is clicked', async () => {
    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Open modal
    await user.click(screen.getByTestId('{componentNameCamelCase}-open-modal'));
    
    // Modal should be visible
    expect(screen.getByTestId('{componentNameCamelCase}-modal')).toBeInTheDocument();
    
    // Click modal backdrop
    const backdrop = screen.getByTestId('{componentNameCamelCase}-modal-backdrop');
    await user.click(backdrop);
    
    // Modal should be closed
    await waitFor(() => {
      expect(screen.queryByTestId('{componentNameCamelCase}-modal')).not.toBeInTheDocument();
    });
  });

  it('closes modal when escape key is pressed', async () => {
    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Open modal
    await user.click(screen.getByTestId('{componentNameCamelCase}-open-modal'));
    
    // Modal should be visible
    expect(screen.getByTestId('{componentNameCamelCase}-modal')).toBeInTheDocument();
    
    // Press escape key
    await user.keyboard('{Escape}');
    
    // Modal should be closed
    await waitFor(() => {
      expect(screen.queryByTestId('{componentNameCamelCase}-modal')).not.toBeInTheDocument();
    });
  });

  it('selects item from dropdown menu', async () => {
    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Find dropdown button
    const dropdownButton = screen.getByTestId('{componentNameCamelCase}-dropdown-button');
    
    // Initially, dropdown menu should not be visible
    expect(screen.queryByTestId('{componentNameCamelCase}-dropdown-menu')).not.toBeInTheDocument();
    
    // Click dropdown button
    await user.click(dropdownButton);
    
    // Dropdown menu should now be visible
    expect(screen.getByTestId('{componentNameCamelCase}-dropdown-menu')).toBeInTheDocument();
    
    // Find menu item
    const menuItem = screen.getByTestId('{componentNameCamelCase}-dropdown-item-1');
    
    // Click menu item
    await user.click(menuItem);
    
    // Menu should close after selection
    expect(screen.queryByTestId('{componentNameCamelCase}-dropdown-menu')).not.toBeInTheDocument();
    
    // Selected item should be reflected in the UI
    expect(screen.getByTestId('{componentNameCamelCase}-selected-item')).toHaveTextContent('Option 1');
  });

  it('triggers callback when delete button is clicked', async () => {
    const mockOnDelete = jest.fn();
    const user = userEvent.setup();
    
    render(<{componentName} onDelete={mockOnDelete} />);
    
    // Find delete button
    const deleteButton = screen.getByTestId('{componentNameCamelCase}-delete-button');
    
    // Click delete button
    await user.click(deleteButton);
    
    // Confirmation dialog should appear
    expect(screen.getByTestId('{componentNameCamelCase}-confirm-dialog')).toBeInTheDocument();
    
    // Click confirm button
    const confirmButton = screen.getByTestId('{componentNameCamelCase}-confirm-button');
    await user.click(confirmButton);
    
    // Check that callback was called
    expect(mockOnDelete).toHaveBeenCalledTimes(1);
  });

  it('cancels delete action when cancel button is clicked', async () => {
    const mockOnDelete = jest.fn();
    const user = userEvent.setup();
    
    render(<{componentName} onDelete={mockOnDelete} />);
    
    // Find delete button
    const deleteButton = screen.getByTestId('{componentNameCamelCase}-delete-button');
    
    // Click delete button
    await user.click(deleteButton);
    
    // Confirmation dialog should appear
    expect(screen.getByTestId('{componentNameCamelCase}-confirm-dialog')).toBeInTheDocument();
    
    // Click cancel button
    const cancelButton = screen.getByTestId('{componentNameCamelCase}-cancel-button');
    await user.click(cancelButton);
    
    // Confirmation dialog should close
    expect(screen.queryByTestId('{componentNameCamelCase}-confirm-dialog')).not.toBeInTheDocument();
    
    // Callback should not have been called
    expect(mockOnDelete).not.toHaveBeenCalled();
  });

  it('handles drag and drop interaction', async () => {
    const mockOnDrop = jest.fn();
    
    render(<{componentName} onDrop={mockOnDrop} />);
    
    // Find draggable element
    const draggable = screen.getByTestId('{componentNameCamelCase}-draggable');
    
    // Find drop target
    const dropTarget = screen.getByTestId('{componentNameCamelCase}-drop-target');
    
    // Simulate drag and drop using fireEvent (userEvent doesn't fully support drag and drop yet)
    fireEvent.dragStart(draggable);
    fireEvent.dragOver(dropTarget);
    fireEvent.drop(dropTarget);
    
    // Check that onDrop callback was called with expected data
    expect(mockOnDrop).toHaveBeenCalledTimes(1);
    expect(mockOnDrop).toHaveBeenCalledWith(expect.objectContaining({
      id: expect.any(String)
    }));
  });
});
