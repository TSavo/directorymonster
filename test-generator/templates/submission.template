import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { {componentName} } from '@/components/{if category}{category}/{componentName}{else}{componentName}{/if}';

/**
 * Submission tests for the {componentName} component
 * 
 * These tests focus on form submission behavior including:
 * - API interaction during form submission
 * - Loading states during submission
 * - Success and error handling after submission
 * - Redirect behavior after successful submission
 * - Form data processing and transformation
 */
describe('{componentName} Submission', () => {
  
  beforeEach(() => {
    // Mock fetch for API calls
    global.fetch = jest.fn();
    
    // Mock useRouter
    jest.mock('next/navigation', () => ({
      useRouter: () => ({
        push: jest.fn(),
        replace: jest.fn(),
        back: jest.fn()
      })
    }));
  });

  afterEach(() => {
    // Clean up mocks
    jest.restoreAllMocks();
  });

  it('shows loading state during form submission', async () => {
    global.fetch = jest.fn().mockImplementation(() => {
      return new Promise(resolve => {
        // Delay to simulate loading
        setTimeout(() => {
          resolve({
            ok: true,
            json: () => Promise.resolve({ success: true })
          });
        }, 100);
      });
    });

    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Fill form with valid data
    await user.type(screen.getByTestId('{componentNameCamelCase}-name'), 'Test Name');
    
    // Submit form
    await user.click(screen.getByTestId('{componentNameCamelCase}-submit'));
    
    // Check loading state
    expect(screen.getByTestId('{componentNameCamelCase}-submit-loading')).toBeInTheDocument();
    expect(screen.getByTestId('{componentNameCamelCase}-submit')).toBeDisabled();
    
    // Wait for submission to complete
    await waitFor(() => {
      expect(screen.queryByTestId('{componentNameCamelCase}-submit-loading')).not.toBeInTheDocument();
    });
  });

  it('sends correct data to API on form submission', async () => {
    // Mock fetch to resolve successfully
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true })
      });
    });

    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Fill form with valid data
    const testName = 'Test Name';
    
    await user.type(screen.getByTestId('{componentNameCamelCase}-name'), testName);
    
    // Submit form
    await user.click(screen.getByTestId('{componentNameCamelCase}-submit'));
    
    // Wait for submission to complete
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(1);
    });
    
    // Check that correct data was sent
    expect(global.fetch).toHaveBeenCalledWith(
      '/api/endpoint',
      expect.objectContaining({
        method: 'POST',
        headers: expect.objectContaining({
          'Content-Type': 'application/json'
        }),
        body: JSON.stringify({
          name: testName
        })
      })
    );
  });

  it('handles successful form submission with success message', async () => {
    // Mock fetch to resolve successfully
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ 
          success: true
        })
      });
    });

    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Fill form with valid data
    await user.type(screen.getByTestId('{componentNameCamelCase}-name'), 'Test Name');
    
    // Submit form
    await user.click(screen.getByTestId('{componentNameCamelCase}-submit'));
    
    // Wait for submission to complete and check success message
    await waitFor(() => {
      expect(screen.getByTestId('{componentNameCamelCase}-success')).toBeInTheDocument();
      expect(screen.getByTestId('{componentNameCamelCase}-success')).toHaveTextContent('Successfully created');
    });
  });

  it('handles API errors during form submission', async () => {
    // Mock fetch to reject with an error
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.resolve({
        ok: false,
        status: 500,
        json: () => Promise.resolve({ 
          success: false, 
          error: 'Server error' 
        })
      });
    });

    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Fill form with valid data
    await user.type(screen.getByTestId('{componentNameCamelCase}-name'), 'Test Name');
    
    // Submit form
    await user.click(screen.getByTestId('{componentNameCamelCase}-submit'));
    
    // Wait for submission to complete and check error message
    await waitFor(() => {
      expect(screen.getByTestId('{componentNameCamelCase}-error')).toBeInTheDocument();
      expect(screen.getByTestId('{componentNameCamelCase}-error')).toHaveTextContent('Server error');
    });
    
    // Verify the form is still enabled for editing
    expect(screen.getByTestId('{componentNameCamelCase}-name')).not.toBeDisabled();
    expect(screen.getByTestId('{componentNameCamelCase}-submit')).not.toBeDisabled();
  });

  it('redirects to the appropriate page after successful submission', async () => {
    // Mock router
    const mockPush = jest.fn();
    jest.mock('next/navigation', () => ({
      useRouter: () => ({
        push: mockPush,
        replace: jest.fn(),
        back: jest.fn()
      })
    }));
    
    // Mock fetch to resolve successfully
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ 
          success: true,
          id: '123'
        })
      });
    });

    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Fill form with valid data
    await user.type(screen.getByTestId('{componentNameCamelCase}-name'), 'Test Name');
    
    // Submit form
    await user.click(screen.getByTestId('{componentNameCamelCase}-submit'));
    
    // Wait for submission to complete
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(1);
    });
    
    // Check redirect
    expect(mockPush).toHaveBeenCalledWith('/success/123');
  });

  it('disables form inputs during submission', async () => {
    // Mock fetch with delay
    global.fetch = jest.fn().mockImplementation(() => {
      return new Promise(resolve => {
        setTimeout(() => {
          resolve({
            ok: true,
            json: () => Promise.resolve({ success: true })
          });
        }, 100);
      });
    });

    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Fill form with valid data
    await user.type(screen.getByTestId('{componentNameCamelCase}-name'), 'Test Name');
    
    // Submit form
    await user.click(screen.getByTestId('{componentNameCamelCase}-submit'));
    
    // Check that form inputs are disabled during submission
    expect(screen.getByTestId('{componentNameCamelCase}-name')).toBeDisabled();
    expect(screen.getByTestId('{componentNameCamelCase}-submit')).toBeDisabled();
    
    // Wait for submission to complete
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(1);
    });
  });

  it('transforms form data correctly before submission', async () => {
    // Mock fetch to resolve successfully
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true })
      });
    });

    const user = userEvent.setup();
    render(<{componentName} />);
    
    // Fill form with data that needs transformation
    const testName = '  Test Name with Spaces  '; // Has leading/trailing spaces
    
    await user.type(screen.getByTestId('{componentNameCamelCase}-name'), testName);
    
    // Submit form
    await user.click(screen.getByTestId('{componentNameCamelCase}-submit'));
    
    // Wait for submission to complete
    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(1);
    });
    
    // Check that data was transformed correctly before sending
    expect(global.fetch).toHaveBeenCalledWith(
      '/api/endpoint',
      expect.objectContaining({
        body: expect.stringContaining('Test Name with Spaces') // Spaces trimmed
      })
    );
  });

});
